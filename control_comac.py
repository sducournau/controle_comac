# -*- coding: utf-8 -*-
"""
/***************************************************************************
 ControlComac
                                 A QGIS plugin
 Un plugin qui contrôle les études COMAC
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2020-10-31
        git sha              : $Format:%H$
        copyright            : (C) 2020 by Simon Ducournau
        email                : simon.ducournau@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
# from qgis.PyQt import QtCore, QtGui, QtWidgets
from qgis.PyQt.QtCore import *
from qgis.PyQt.QtGui import *
from qgis.PyQt import QtGui
from qgis.PyQt.QtWidgets import *
from qgis.core import *
from qgis.utils import iface
from functools import partial
import subprocess
import psycopg2
from .resources import *
from .control_comac_dockwidget import ControlComacDockWidget
from .eplan import *
import threading
from .utils import *
from .ImportTask import *
from .MajTask import *


        # self.bar.hide()
CONNECTION = utils.CONNECTION



class ControlComac:
    """QGIS Plugin Implementation."""


    def __init__(self, iface):



        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface

        self.iface = iface
        self.nb_results = 0
        self.etudes = None
        self.task_import = None
        self.task_maj = None

        print(PATH_ABSOLUTE_PROJECT)
        print(DIR_PLUGIN)
        print(DIR_STYLES)

        # self.filename_log = PATH_ABSOLUTE_PROJECT + os.sep + 'history.log'
        #
        # def write_log_message(message, tag, level):
        #     with open(self.filename_log, 'a') as logfile:
        #         logfile.write('{tag}({level}): {message}\n'.format(tag=tag, level=level, message=message))
        #
        # QgsApplication.messageLog().messageReceived.connect(write_log_message)

        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            DIR_PLUGIN,
            'i18n',
            'ControlComac_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&Outils Circet')
        # TODO: We are going to let the user set this up in a future iteration
        self.toolbar = self.iface.addToolBar(u'ControlComac')
        self.toolbar.setObjectName(u'ControlComac')

        #print "** INITIALIZING ControlComac"

        self.pluginIsActive = False
        self.dockwidget = None


    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('ControlComac', message)





    def managerTask(self, task_name):

        self.layer_name = None
        index = self.dockwidget.tabs.currentIndex()
        if index == 1:
            self.layer_name = 'appuis_comac'
            self.seldir.import_files_and_directories(self.layer_name)
        elif index == 2:
            self.layer_name = 'appuis_capft'
            self.seldir.import_files_and_directories(self.layer_name)
        t0 = time.time()

        # self.prog = QProgressDialog('Calcul en cours...', 'Annuler', 0, 100)
        # self.prog.setWindowModality(Qt.WindowModal)
        # self.prog.setMinimum(0)
        # self.prog.setMaximum(0)
        # self.prog.setValue(0)
        self.task_name = task_name


        if self.task_name == 'Importation' and self.layer_name is not None:

            utils.GROUP_LAYER = utils.ROOT.findGroup(utils.GROUP_NAME)
            utils.TYPE_LAYER = utils.ROOT.findGroup(self.layer_name)

            if utils.GROUP_LAYER is not None:
                if utils.TYPE_LAYER is not None:
                    for child in utils.TYPE_LAYER.children():
                        utils.PROJECT.removeMapLayers([child.layerId()])
                else:
                    utils.TYPE_LAYER = utils.GROUP_LAYER.insertGroup(0, self.layer_name)

            else:
                utils.GROUP_LAYER = utils.ROOT.insertGroup(0, utils.GROUP_NAME)
                utils.TYPE_LAYER = utils.GROUP_LAYER.insertGroup(0, self.layer_name)

            layers = iface.mapCanvas().layers()
            for layer in layers:
                if layer.name() == self.layer_name:
                    utils.PROJECT.removeMapLayers( [layer.id()] )

            self.task_end = FilterLayers('Filtrer les couches', self.dockwidget, 'end' , None)

            self.task_import =  ImportTask(self.task_name,self.dockwidget,self.layer_name)

            self.task_import.begun.connect(lambda:  iface.messageBar().pushMessage('L\'import débute'))

            # self.task.progressChanged.connect(lambda: prog.setValue(self.task.progress()))
            self.task_import.taskCompleted.connect(lambda: print(time.time() - t0 ))

            self.task_import.addSubTask(self.task_end, [], QgsTask.ParentDependsOnSubTask)

            QgsApplication.taskManager().addTask(self.task_import)
            self.task_import.taskCompleted.connect(lambda: self.create_meta_layers())

        elif self.task_name == 'Mise à jour' and self.layer_name is not None:


            self.task_start = FilterLayers('Filtrer les couches', self.dockwidget, 'start' , self.layer_name)
            self.task_end = FilterLayers('Filtrer les couches', self.dockwidget, 'end' , self.layer_name)

            self.task_maj = MajTask(self.task_name + ' des ' + self.layer_name,self.layer_name,self.dockwidget)
            self.task_maj.begun.connect(lambda:  iface.messageBar().pushMessage('La mise à jour depuis la couche {} débute'.format(str(self.layer_name))))

            # self.task.progressChanged.connect(lambda: print(self.task.progress()))
            self.task_maj.taskCompleted.connect(lambda: print(time.time() - t0 ))

            self.task_maj.addSubTask(self.task_start, [], QgsTask.ParentDependsOnSubTask)
            # self.task_maj.addSubTask(self.task_end , [self.task_maj])

            QgsApplication.taskManager().addTask(self.task_maj)
            self.task_maj.taskCompleted.connect(lambda: self.refresh_map())


    def create_meta_layers(self):

        file = utils.DIR_OUTPUT_ + 'export_portee_'  + self.layer_name + '.json'

        layer_for_edit = QgsProject().instance().mapLayersByName(self.layer_name)[0]

        if self.layer_name == 'appuis_comac':
            data = {}
            with open(file) as json_file:
                data = json.load(json_file)


            layer_line_fibre =  QgsVectorLayer("LineString?crs=epsg:2154&field=id:integer&index=yes","Line","memory")
            pr = layer_line_fibre.dataProvider()
            pr.addAttributes([
                          QgsField("Etude",  QVariant.String),
                          QgsField("Angle", QVariant.String),
                          QgsField("Longueur", QVariant.String),
                          QgsField("Type", QVariant.String),
                          QgsField("troncon", QVariant.String),
                          QgsField("Appui_1", QVariant.String),
                          QgsField("Appui_2", QVariant.String),
                          QgsField("za_nro", QVariant.String),
                          QgsField("za_zpm", QVariant.String)])
            layer_line_fibre.updateFields()
            layer_line_fibre.setName("Lignes_Fibre")
            layer_line_fibre.loadNamedStyle(utils.DIR_STYLES + os.sep +  'lignes_fibre.qml')
            utils.PROJECT.addMapLayer(layer_line_fibre, False)
            utils.TYPE_LAYER.insertChildNode(0, QgsLayerTreeLayer(layer_line_fibre))



            for etude in data:
                print(etude)
                etude = etude.replace("\'", "")
                print(etude)
                layer_for_edit.selectByExpression('"Etude" = \'' + etude + '\'', QgsVectorLayer.SetSelection)
                selection =  layer_for_edit.selectedFeatures()
                for ligne in data[etude]['Fibre']['Lignes']:
                    for portee in ligne['Portees']:
                        troncon = ''
                        list = portee.split(' - ')

                        list_point = []
                        za_nro = ''
                        za_zpm = ''
                        for feature in list:
                            for feat in selection:
                                if feature == feat['Nom']:
                                    list_point.append(QgsPointXY(QgsGeometry.asPoint(feat.geometry())))
                                    troncon = feat['troncon']
                                    za_nro = feat['za_nro']
                                    za_zpm = feat['za_zpm']
                        infos = ligne['Portees'][portee]

                        line_feature = QgsFeature(layer_line_fibre.fields())
                        line_feature.setGeometry(QgsGeometry.fromPolylineXY(list_point))
                        line_feature["Etude"] = etude
                        line_feature["Angle"] = infos[1]
                        line_feature["Longueur"] = infos[0]
                        line_feature["Type"] = ligne['Cable']
                        line_feature["troncon"] = troncon
                        line_feature["Appui_1"] = list[0]
                        line_feature["Appui_2"] = list[1]
                        line_feature["za_nro"] = za_nro
                        line_feature["za_zpm"] = za_zpm
                        layer_line_fibre.startEditing()
                        layer_line_fibre.addFeature(line_feature)
                        layer_line_fibre.commitChanges()


            layer_line_bt =  QgsVectorLayer("LineString?crs=epsg:2154&field=id:integer&index=yes","Line","memory")
            pr = layer_line_bt.dataProvider()
            pr.addAttributes([
                          QgsField("Etude",  QVariant.String),
                          QgsField("Angle", QVariant.String),
                          QgsField("Longueur", QVariant.String),
                          QgsField("Type", QVariant.String),
                          QgsField("troncon", QVariant.String),
                          QgsField("Appui_1", QVariant.String),
                          QgsField("Appui_2", QVariant.String),
                          QgsField("za_nro", QVariant.String),
                          QgsField("za_zpm", QVariant.String)])
            layer_line_bt.updateFields()
            layer_line_bt.setName("Lignes_BT")
            layer_line_bt.loadNamedStyle(utils.DIR_STYLES + os.sep +  'lignes_bt.qml')

            utils.PROJECT.addMapLayer(layer_line_bt, False)
            utils.TYPE_LAYER.insertChildNode(0, QgsLayerTreeLayer(layer_line_bt))



            for etude in data:
                layer_for_edit.selectByExpression('"Etude" = \'' + etude + '\'', QgsVectorLayer.SetSelection)
                selection =  layer_for_edit.selectedFeatures()
                for ligne in data[etude]['BT']['Lignes']:

                    for portee in ligne['Portees']:
                        troncon = ''
                        list = portee.split(' - ')
                        za_nro = ''
                        za_zpm = ''
                        list_point = []
                        for feature in list:
                            for feat in selection:
                                if feature == feat['Nom']:
                                    list_point.append(QgsPointXY(QgsGeometry.asPoint(feat.geometry())))
                                    troncon = feat['troncon']
                                    za_nro = feat['za_nro']
                                    za_zpm = feat['za_zpm']

                        infos = ligne['Portees'][portee]

                        line_feature = QgsFeature(layer_line_bt.fields())
                        line_feature.setGeometry(QgsGeometry.fromPolylineXY(list_point))
                        line_feature["Etude"] = etude
                        line_feature["Angle"] = infos[1]
                        line_feature["Longueur"] = infos[0]
                        line_feature["Type"] = ligne['Conducteur']
                        line_feature["troncon"] = troncon
                        line_feature["Appui_1"] = list[0]
                        line_feature["Appui_2"] = list[1]
                        line_feature["za_nro"] = za_nro
                        line_feature["za_zpm"] = za_zpm
                        layer_line_bt.startEditing()
                        layer_line_bt.addFeature(line_feature)
                        layer_line_bt.commitChanges()



            outputs = {}

            alg_params_extract = {
                'EXPRESSION':'"troncon" is not null',
                'INPUT': layer_line_bt,
                'OUTPUT': 'TEMPORARY_OUTPUT'
            }
            outputs['alg_params_extract'] = processing.run('qgis:extractbyexpression', alg_params_extract)

            alg_params_dissolve = {
                'FIELD': ['Etude'],
                'INPUT': outputs['alg_params_extract']['OUTPUT'],
                'OUTPUT': 'TEMPORARY_OUTPUT'
            }
            outputs['alg_params_dissolve'] = processing.run('qgis:dissolve', alg_params_dissolve)

            alg_params_buffer_d2 = {
                'DISSOLVE': False,
                'DISTANCE': 10,
                'END_CAP_STYLE': 2,
                'INPUT': outputs['alg_params_dissolve']['OUTPUT'],
                'JOIN_STYLE': 2,
                'MITER_LIMIT': 2,
                'SEGMENTS': 5,
                'OUTPUT': 'TEMPORARY_OUTPUT'
            }
            outputs['alg_params_buffer_d2'] = processing.run('qgis:buffer', alg_params_buffer_d2)
            layer_gpkg_d2 = outputs['alg_params_buffer_d2']['OUTPUT']




            alg_params_dissolve = {
                'FIELD': ['Etude'],
                'INPUT': layer_line_fibre,
                'OUTPUT': 'TEMPORARY_OUTPUT'
            }
            outputs['alg_params_dissolve'] = processing.run('qgis:dissolve', alg_params_dissolve)

            alg_params_buffer_d2 = {
                'DISSOLVE': False,
                'DISTANCE': 10,
                'END_CAP_STYLE': 2,
                'INPUT': outputs['alg_params_dissolve']['OUTPUT'],
                'JOIN_STYLE': 2,
                'MITER_LIMIT': 2,
                'SEGMENTS': 5,
                'OUTPUT': 'TEMPORARY_OUTPUT'
            }
            outputs['alg_params_buffer_d2'] = processing.run('qgis:buffer', alg_params_buffer_d2)
            layer_gpkg_d2_ = outputs['alg_params_buffer_d2']['OUTPUT']

            etudes_ok = []
            for feature in layer_gpkg_d2_.getFeatures():
                if feature['Etude'] not in etudes_ok:
                    etudes_ok.append(feature['Etude'])

            alg_params_extract = {
                'EXPRESSION':' "troncon" is not null',
                'INPUT': layer_for_edit,
                'OUTPUT': 'TEMPORARY_OUTPUT'
            }
            outputs['alg_params_extract'] = processing.run('qgis:extractbyexpression', alg_params_extract)

            alg_params_buffer_d3 = {
                'DISSOLVE': False,
                'DISTANCE': 10,
                'END_CAP_STYLE': 2,
                'INPUT': outputs['alg_params_extract']['OUTPUT'],
                'JOIN_STYLE': 2,
                'MITER_LIMIT': 2,
                'SEGMENTS': 5,
                'OUTPUT': 'TEMPORARY_OUTPUT'
            }
            outputs['alg_params_buffer_d3'] = processing.run('qgis:buffer', alg_params_buffer_d3)
            layer_gpkg_d3 = outputs['alg_params_buffer_d3']['OUTPUT']


            alg_params_merge = {
                'CRS': 'EPSG:2154',
                'LAYERS': [layer_gpkg_d2,layer_gpkg_d2_,layer_gpkg_d3],
                'OUTPUT': 'TEMPORARY_OUTPUT'
            }
            outputs['alg_params_merge'] = processing.run('qgis:mergevectorlayers', alg_params_merge)

            alg_params_dissolve = {
                'FIELD': ['Etude'],
                'INPUT': outputs['alg_params_merge']['OUTPUT'],
                'OUTPUT': 'TEMPORARY_OUTPUT'
            }
            outputs['alg_params_dissolve'] = processing.run('qgis:dissolve', alg_params_dissolve)

            alg_params_simplify = {
                'INPUT': outputs['alg_params_dissolve']['OUTPUT'],
                'METHOD': 0,
                'TOLERANCE': 3,
                'OUTPUT': 'TEMPORARY_OUTPUT'
            }
            outputs['alg_params_simplify'] = processing.run('qgis:simplifygeometries', alg_params_simplify)

            alg_params_refactor = {
                'FIELDS_MAPPING': [{'expression': '"Etude"','length': 100,'name': 'Etude','precision': 0,'type': 10},{'expression': '"za_nro"','length': 50,'name': 'za_nro','precision': 0,'type': 10},{'expression': '"za_zpm"','length': 50,'name': 'za_zpm','precision': 0,'type': 10}],
                'INPUT': outputs['alg_params_simplify']['OUTPUT'],
                'OUTPUT': 'TEMPORARY_OUTPUT'
            }
            outputs['alg_params_refactor'] = processing.run('qgis:refactorfields', alg_params_refactor)

            layer_gpkg = outputs['alg_params_refactor']['OUTPUT']
            layer_gpkg.setName("Zone d'étude")
            layer_gpkg.loadNamedStyle(utils.DIR_STYLES + os.sep +  'zone_etude.qml')
            utils.PROJECT.addMapLayer(layer_gpkg, False)
            utils.TYPE_LAYER.addLayer(layer_gpkg)

            uri_option = '?encoding=windows-1252&type=csv&delimiter=;&detectTypes=yes&decimalPoint=,&subsetIndex=no&watchFile=yes'
            csv_path = utils.DIR_OUTPUT_ + 'export_tableau_suivi_enedis.csv'
            uri = 'file:///' + csv_path + uri_option
            layer_csv = QgsVectorLayer(uri, 'export_tableau_suivi_enedis', 'delimitedtext')
            utils.PROJECT.addMapLayer(layer_csv, False)
            utils.TYPE_LAYER.insertChildNode(0, QgsLayerTreeLayer(layer_csv))

            # Set properties for the join
            shpField='Etude'
            csvField='Nom d\'affaire E-PLAN'
            joinObject = QgsVectorLayerJoinInfo()
            joinObject.setJoinLayerId(layer_csv.id())
            joinObject.setJoinFieldName(csvField)
            joinObject.setTargetFieldName(shpField)
            joinObject.setUsingMemoryCache(True)
            joinObject.setPrefix('enedis_')
            joinObject.setJoinLayer(layer_csv)
            layer_gpkg.addJoin(joinObject)

        if self.layer_name == 'appuis_capft':
            layer_line_fibre =  QgsVectorLayer("LineString?crs=epsg:2154&field=id:integer&index=yes","Line","memory")
            pr = layer_line_fibre.dataProvider()
            pr.addAttributes([
                          QgsField("Etude",  QVariant.String),
                          QgsField("Angle", QVariant.String),
                          QgsField("Longueur", QVariant.String),
                          QgsField("Type", QVariant.String),
                          QgsField("Appui_1", QVariant.String),
                          QgsField("Appui_2", QVariant.String),
                          QgsField("za_nro", QVariant.String),
                          QgsField("za_zpm", QVariant.String)])
            layer_line_fibre.updateFields()
            layer_line_fibre.setName("Lignes_Fibre")
            layer_line_fibre.loadNamedStyle(utils.DIR_STYLES + os.sep +  'lignes_fibre.qml')
            utils.PROJECT.addMapLayer(layer_line_fibre, False)
            utils.TYPE_LAYER.insertChildNode(0, QgsLayerTreeLayer(layer_line_fibre))


            for feature in layer_for_edit.getFeatures():
                list_point = []
                za_nro = ''
                za_zpm = ''
                list_point.append(QgsPointXY(QgsGeometry.asPoint(feature.geometry())))

                for feat in layer_for_edit.getFeatures():
                    if feature['N° appui destination'] == feat['N° appui']:
                        list_point.append(QgsPointXY(QgsGeometry.asPoint(feat.geometry())))

                line_feature = QgsFeature(layer_line_fibre.fields())
                line_feature.setGeometry(QgsGeometry.fromPolylineXY(list_point))
                line_feature["Etude"] = feature['Etude']
                line_feature["Angle"] = feature['Angle en grade']
                line_feature["Longueur"] = feature['Longueur portée']
                line_feature["Type"] = feature['Nom du câble']
                line_feature["Appui_1"] = feature['N° appui']
                line_feature["Appui_2"] = feat['N° appui']
                line_feature["za_nro"] = feature['za_nro']
                line_feature["za_zpm"] = feature['za_zpm']
                layer_line_fibre.startEditing()
                layer_line_fibre.addFeature(line_feature)
                layer_line_fibre.commitChanges()
        layer_for_edit.removeSelection()
        self.refresh_map()


    def refresh_map(self):

        for layer in iface.mapCanvas().layers():
            if isinstance(layer, QgsVectorLayer):
                layer.dataProvider().forceReload()
                layer.triggerRepaint()
        print('refresh')
            # print('task_maj running')
    def cancelTask(self):
        self.task.cancel()

    def reset(self):

        root = utils.PROJECT.layerTreeRoot()
        group = root.findGroup(utils.GROUP_NAME)
        if group is not None:
            for child in group.children():
                if 'manquants' in child.name() or 'compare' in child.name():
                    utils.PROJECT.removeMapLayers([child.layerId()])


        self.layers = QgsProject.instance().mapLayers().values()
        if self.dockwidget.checkBox_numerotation.checkState() == 2:
            self.incrementation_appuis_gest('reset')

        for layer in self.layers:
            if isinstance(layer, QgsVectorLayer):
                iface.vectorLayerTools().stopEditing(layer,False)
                layer.setSubsetString('')
        return True


    def save(self):

        root = utils.PROJECT.layerTreeRoot()
        group = root.findGroup(utils.GROUP_NAME)
        if group is not None:
            for child in group.children():
                if 'manquants' in child.name() or 'compare' in child.name():
                    utils.PROJECT.removeMapLayers([child.layerId()])

        self.layers = QgsProject.instance().mapLayers().values()
        if self.dockwidget.checkBox_numerotation.checkState() == 2:
            self.incrementation_appuis_gest('save')

        for layer in self.layers:
            if isinstance(layer, QgsVectorLayer):
                layer.commitChanges()
                layer.setSubsetString('')
        return True


    def incrementation_appuis_gest(self, task):
        # Connect to an existing database



        global CONNECTION
        cur = CONNECTION.cursor()
        vals = []
        if utils.GESTIONNAIRE_LIST_APPUIS:
            for val in utils.GESTIONNAIRE_LIST_APPUIS:
                vals.append(val['numero'])
            print(utils.GESTIONNAIRE_LIST_APPUIS)
            if task == 'save':

                print("""SELECT * FROM """ + '.'.join([utils.SCHEMA,utils.TABLE_NUM_APPUI]) + """ WHERE  """ + utils.TABLE_NUM_APPUI + """.etat = 'edition' AND  """ + utils.TABLE_NUM_APPUI + """.numero IN ('{}');""".format(str("','".join(vals))))
                cur.execute("""SELECT * FROM """ + '.'.join([utils.SCHEMA,utils.TABLE_NUM_APPUI]) + """ WHERE  """ + utils.TABLE_NUM_APPUI + """.etat = 'edition' AND  """ + utils.TABLE_NUM_APPUI + """.numero IN ('{}');""".format(str("','".join(vals))))

                results = cur.fetchall()

                if len(utils.GESTIONNAIRE_LIST_APPUIS) == len(results):
                    for i, result in enumerate(results):
                        cur.execute("""UPDATE """ + '.'.join([utils.SCHEMA,utils.TABLE_NUM_APPUI]) + """ SET etat = 'ok' WHERE  """ + utils.TABLE_NUM_APPUI + """.code_id IN ({});""".format(str(result[0])))
                        CONNECTION.commit()
                    cur.close()

            elif task == 'reset':

                print("""SELECT * FROM """ + '.'.join([utils.SCHEMA,utils.TABLE_NUM_APPUI]) + """ WHERE  """ + utils.TABLE_NUM_APPUI + """.etat = 'edition' AND  """ + utils.TABLE_NUM_APPUI + """.numero IN ('{}');""".format(str("','".join(vals))))
                cur.execute("""SELECT * FROM """ + '.'.join([utils.SCHEMA,utils.TABLE_NUM_APPUI]) + """ WHERE """ + utils.TABLE_NUM_APPUI + """.etat = 'edition' AND  """ + utils.TABLE_NUM_APPUI + """.numero IN ('{}');""".format(str("','".join(vals))))

                results = cur.fetchall()

                if len(utils.GESTIONNAIRE_LIST_APPUIS) == len(results):
                    for i, result in enumerate(results):
                        cur.execute("""UPDATE """ + '.'.join([utils.SCHEMA,utils.TABLE_NUM_APPUI]) + """ SET etat = 'nok' WHERE """ + utils.TABLE_NUM_APPUI + """.code_id IN ({});""".format(str(result[0])))
                        CONNECTION.commit()
                    cur.close()






    def rewrite_config(self):
        PRECEDENT_GESTIONNAIRE = utils.config_data['GESTIONNAIRE']
        PRECEDENTE_CONNEXION = utils.config_data['CONNEXION']
        utils.config_data['GESTIONNAIRE'] = self.dockwidget.lineEdit_config_gestionnaire.text()
        utils.config_data['CONNEXION'] = self.dockwidget.lineEdit_config_connexionbdd.text()
        utils.config_data['SCHEMA'] = self.dockwidget.lineEdit_config_connexionbdd_schema.text()
        utils.config_data['TABLE_NUM_APPUI'] = self.dockwidget.lineEdit_config_connexionbdd_tablenum.text()
        utils.config_data['EPLAN']['id'] = self.dockwidget.lineEdit_id.text()
        utils.config_data['EPLAN']['mpd'] = self.dockwidget.lineEdit_mpd.text()
        self.dockwidget.checkBox_comac_create_athd.setText('Créer les appuis {}'.format(str(utils.config_data['GESTIONNAIRE'])))
        self.dockwidget.checkBox_capft_create_athd.setText('Créer les appuis {}'.format(str(utils.config_data['GESTIONNAIRE'])))
        utils.reload_config(utils.config_data, PRECEDENT_GESTIONNAIRE)

    def open_folder(self):

        subprocess.call("explorer " + utils.DIR_OUTPUT_, shell=True)

    def change_pcm_rayon(self, text):

        utils.PCM_RAYON = text
        self.dockwidget.lineEdit_pcm_rayon.setText(str(utils.PCM_RAYON))
        print(utils.PCM_RAYON)




    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            self.toolbar.addAction(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action


    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/control_comac/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'Contrôle Comac'),
            callback=self.run,
            parent=self.iface.mainWindow())

    #--------------------------------------------------------------------------

    def onClosePlugin(self):
        """Cleanup necessary items here when plugin dockwidget is closed"""

        #print "** CLOSING ControlComac"

        # disconnects
        self.dockwidget.closingPlugin.disconnect(self.onClosePlugin)

        # remove this statement if dockwidget is to remain
        # for reuse if plugin is reopened
        # Commented next statement since it causes QGIS crashe
        # when closing the docked window:
        # self.dockwidget = None

        self.pluginIsActive = False


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""

        #print "** UNLOAD ControlComac"

        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&Contrôle Comac'),
                action)
            self.iface.removeToolBarIcon(action)
        # remove the toolbar
        del self.toolbar



    #--------------------------------------------------------------------------------#
    #                                 PLUGINS                                        #
    #--------------------------------------------------------------------------------#



    def eplan_task(self, task):

        id = self.dockwidget.lineEdit_id.text()
        mpd = self.dockwidget.lineEdit_mpd.text()

        if task == 'depose_etude':
            depose = self.dockwidget.checkBox_envoi.checkState()
            excel = self.dockwidget.checkBox_excel.checkState()
            convention = utils.eplan_convention_list[self.dockwidget.comboBox_convention.currentText()]
            type_etude = self.dockwidget.comboBox_type.currentText()

            self.rewrite_config()
            if convention != "-1":
                ePlanTask = ePlanAutoDeposeEtude('Depose E-Plan',id, mpd,convention, type_etude,depose,excel)
                ePlanTask.start()
                #QgsApplication.taskManager().addTask(ePlanTask)
            else:
                iface.messageBar().pushMessage("Error",'Aucune convention sélectionnée...', level=Qgis.Critical)

        elif task == 'charger_export':

            dr = self.dockwidget.comboBox_dr.currentText()
            operateur = self.dockwidget.lineEdit_operateur.text()
            departement = self.dockwidget.lineEdit_departement.text()
            date = self.dockwidget.lineEdit_date.text()
            ePlanTask = ePlanAutoExportBrut('Charger export brut',id, mpd, dr, operateur, departement, date)
            ePlanTask.start()


    def change_background_color(self):
        color = self.dockwidget.mColorButton.color()
        color_value = color.name()
        style = "QWidget { background-color: %s; }" % color_value
        self.dockwidget.tabs.setAutoFillBackground(True)
        self.dockwidget.tabs.setStyleSheet(style)
        self.dockwidget.tabs.update()



    def run(self):
        """Run method that loads and starts the plugin"""

        if not self.pluginIsActive:
            self.pluginIsActive = True

            #print "** STARTING ControlComac"

            # dockwidget may not exist if:
            #    first run of plugin
            #    removed on close (see self.onClosePlugin method)
            if self.dockwidget == None:
                # Create the dockwidget (after translation) and keep reference

                self.dockwidget = ControlComacDockWidget()
                self.seldir = selectDirectories(self.dockwidget)
                self.populate = populateComboBox(self.dockwidget)
                self.seldir.init_import_directory()


                #comac tab
                self.dockwidget.checkBox_comac_create_athd.setText('Créer les appuis {}'.format(str(utils.config_data['GESTIONNAIRE'])))
                self.dockwidget.lineEdit_export_dir.setText(utils.config_data['DIR_OUTPUT'])

                self.dockwidget.pushButton_comac_import_dir.clicked.connect(self.seldir.select_import_folder)



                self.dockwidget.comboBox_comac_select_za_nro.currentIndexChanged.connect(partial(self.populate.populate_za_zpm,'appuis_comac'))
                self.dockwidget.comboBox_comac_select_za_nro.currentIndexChanged.connect(partial(self.populate.populate_etudes,'appuis_comac'))
                self.dockwidget.comboBox_comac_select_za_zpm.currentIndexChanged.connect(partial(self.populate.populate_etudes,'appuis_comac'))


                icon = QtGui.QIcon(os.path.join(DIR_PLUGIN,  "images/import.png"))
                self.dockwidget.pushButton_import.setIcon(icon)


                icon = QtGui.QIcon(os.path.join(DIR_PLUGIN,  "images/folder.png"))
                self.dockwidget.pushButton_folder.setIcon(icon)


                icon = QtGui.QIcon(os.path.join(DIR_PLUGIN,  "images/run.png"))
                self.dockwidget.pushButton_calcul.setIcon(icon)


                icon = QtGui.QIcon(os.path.join(DIR_PLUGIN,  "images/save.png"))
                self.dockwidget.pushButton_save.setIcon(icon)


                icon = QtGui.QIcon(os.path.join(DIR_PLUGIN,  "images/reset.png"))
                self.dockwidget.pushButton_reset.setIcon(icon)




                #capft tab
                self.dockwidget.pushButton_capft_import_dir.clicked.connect(self.seldir.select_import_files)


                self.dockwidget.comboBox_capft_select_za_nro.currentIndexChanged.connect(partial(self.populate.populate_za_zpm,'appuis_capft'))
                self.dockwidget.comboBox_capft_select_za_nro.currentIndexChanged.connect(partial(self.populate.populate_etudes,'appuis_capft'))
                self.dockwidget.comboBox_capft_select_za_zpm.currentIndexChanged.connect(partial(self.populate.populate_etudes,'appuis_capft'))

                #plugins
                self.dockwidget.pushButton_eplan.clicked.connect(partial(self.eplan_task,'depose_etude'))
                self.dockwidget.lineEdit_id.setText(str(utils.config_data['EPLAN']['id']))
                self.dockwidget.lineEdit_mpd.setText(str(utils.config_data['EPLAN']['mpd']))
                self.dockwidget.pushButton_color.clicked.connect(self.change_background_color)
                self.dockwidget.pushButton.clicked.connect(partial(self.eplan_task, 'charger_export'))



                #config tab

                self.dockwidget.lineEdit_pcm_rayon.setText(str(utils.PCM_RAYON))
                self.dockwidget.lineEdit_pcm_rayon.textChanged.connect(self.change_pcm_rayon)
                self.dockwidget.lineEdit_config_gestionnaire.setText(str(utils.config_data['GESTIONNAIRE']))
                self.dockwidget.lineEdit_config_connexionbdd.setText(str(utils.config_data['CONNEXION']))
                self.dockwidget.lineEdit_config_connexionbdd_schema.setText(str(utils.config_data['SCHEMA']))
                self.dockwidget.lineEdit_config_connexionbdd_tablenum.setText(str(utils.config_data['TABLE_NUM_APPUI']))
                self.dockwidget.pushButton_config_gestionnaire.clicked.connect(self.rewrite_config)
                self.dockwidget.pushButton_config_connexionbdd.clicked.connect(self.rewrite_config)
                self.dockwidget.pushButton_config_connexionbdd_schema.clicked.connect(self.rewrite_config)
                self.dockwidget.pushButton_config_connexionbdd_tablenum.clicked.connect(self.rewrite_config)
                self.dockwidget.lineEdit_export_dir.editingFinished.connect(self.seldir.update_import_directory)


                self.dockwidget.pushButton_export_dir.clicked.connect(self.seldir.select_export_folder)

                #tabs
                self.dockwidget.tabs.currentChanged.connect(self.populate.onChange_tab)

                #buttons
                self.dockwidget.pushButton_import.clicked.connect(partial(self.managerTask,'Importation'))
                self.dockwidget.pushButton_folder.clicked.connect(self.open_folder)
                self.dockwidget.pushButton_calcul.clicked.connect(partial(self.managerTask,'Mise à jour'))
                self.dockwidget.pushButton_save.clicked.connect(self.save)
                self.dockwidget.pushButton_reset.clicked.connect(self.reset)

            # connect to provide cleanup on closing of dockwidget
            self.dockwidget.closingPlugin.connect(self.onClosePlugin)

            # show the dockwidget
            # TODO: fix to allow choice of dock location
            self.iface.addDockWidget(Qt.RightDockWidgetArea, self.dockwidget)
            self.dockwidget.show()
